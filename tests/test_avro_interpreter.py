import json
import pytest

from src.nypl_py_utils.classes.avro_client import AvroDecoder, AvroEncoder, AvroClientError
from requests.exceptions import ConnectTimeout

_TEST_SCHEMA = {'data': {'schema': json.dumps({
    'name': 'TestSchema',
    'type': 'record',
    'fields': [
        {
            'name': 'patron_id',
            'type': 'int'
        },
        {
            'name': 'library_branch',
            'type': ['null', 'string']
        }
    ]
})}}

_CIRC_TRANS_SCHEMA = {'data': {'schema': json.dumps({
    "name": "CircTransRecord",
    "type": "record",
    "fields": [
      {
        "name": "id",
        "type": "int",
        "doc": "System-generated sequential ID."
      },
      {
        "name": "patron_id",
        "type": [
          "null",
          "int"
        ],
        "doc": "De-identified Patron ID for record"
      },
      {
        "name": "item_id",
        "type": [
          "null",
          "int"
        ],
        "doc": "Item ID for record"
      },
      {
        "name": "volume_id",
        "type": [
          "null",
          "int"
        ],
        "doc": "Volume ID for record"
      },
      {
        "name": "bib_id",
        "type": [
          "null",
          "int"
        ],
        "doc": "Bib ID for record"
      },
      {
        "name": "transaction_gmt",
        "type": [
          "null",
          "string"
        ],
        "doc": "Transaction date in UNIX format."
      },
      {
        "name": "application_name",
        "type": "string",
        "doc": "The name of the program that generated the transaction. Valid program names are: circ (includes transactions made using PC Circ) circa (for transactions written by selfcheckwebserver and in-house use [transaction codes 'u' and 's'], which use webpac to execute transactions.) milcirc milmyselfcheck readreq selfcheck"
      },
      {
        "name": "source_code",
        "type": "string",
        "doc": "The transaction source. Possible values are: local INN-Reach ILL"
      },
      {
        "name": "op_code",
        "type": [
          "null",
          "string"
        ],
        "doc": "Type of transaction: o = checkout i = checkin n = hold nb = bib hold ni = item hold nv = volume hold h = hold with recall hb = hold recall bib hi = hold recall item hv = hold recall volume f = filled hold r = renewal b = booking u = use count"
      },
      {
        "name": "stat_group_code_num",
        "type": [
          "null",
          "int"
        ],
        "doc": "The number of the terminal at which the transaction occurred or the user-specified statistics group number for PC-Circ transactions. Also stores the login's statistics group number for circulation transactions performed with the following Circa applications: checkout checkin count internal use"
      },
      {
        "name": "due_date_gmt",
        "type": [
          "null",
          "string"
        ],
        "doc": "Due date in UNIX format. The application of this date depends on the op_code for the transaction. The due date is not included for bookings (op_code b) or filled holds (op_code f). For op_code 'i' (checkin), this is the original due date. For op_code 'r' (renewal), this is the renewal due date. For op_code 'o' (checkouts), this is the item due date. For op_codes 'n' (holds) and 'h' (holds with recall), a non-zero entry indicates that the hold is for a checked-out item that is due on the specified date."
      },
      {
        "name": "count_type_code_num",
        "type": [
          "null",
          "int"
        ],
        "doc": "Indicates the type of use count (for op_code 'u'): Code Number Count Type 1 INTL USE (fixflds 93) 2 COPY USE (fixflds 94) 3 IUSE3 (fixflds 74) 4 PIUSE: generated by the system"
      },
      {
        "name": "itype_code_num",
        "type": [
          "null",
          "int"
        ],
        "doc": "Item type code. (Defined by the library.)"
      },
      {
        "name": "icode1",
        "type": [
          "null",
          "int"
        ],
        "doc": "Item code 1. (Defined by the library.)"
      },
      {
        "name": "icode2",
        "type": [
          "null",
          "string"
        ],
        "doc": "Item code 2. (Defined by the library.)"
      },
      {
        "name": "item_location_code",
        "type": [
          "null",
          "string"
        ],
        "doc": "A five-character location code, right-padded with spaces, from the associated item record."
      },
      {
        "name": "item_agency_code_num",
        "type": [
          "null",
          "int"
        ],
        "doc": "A one-character AGENCY code from the associated item record."
      },
      {
        "name": "ptype_code",
        "type": [
          "null",
          "string"
        ],
        "doc": "Patron type code. (Defined by the library.)"
      },
      {
        "name": "pcode1",
        "type": [
          "null",
          "string"
        ],
        "doc": "Patron code 1. (Defined by the library.)"
      },
      {
        "name": "pcode2",
        "type": [
          "null",
          "string"
        ],
        "doc": "Patron code 2. (Defined by the library.)"
      },
      {
        "name": "pcode3",
        "type": [
          "null",
          "int"
        ],
        "doc": "Patron code 3. (Defined by the library.)"
      },
      {
        "name": "pcode4",
        "type": [
          "null",
          "int"
        ],
        "doc": "Patron code 4. (Defined by the library.)"
      },
      {
        "name": "patron_home_library_code",
        "type": [
          "null",
          "string"
        ],
        "doc": "A five-character location code, right-padded with spaces, from the associated patron record."
      },
      {
        "name": "patron_agency_code_num",
        "type": [
          "null",
          "int"
        ],
        "doc": "A one-character AGENCY code from the associated patron record."
      },
      {
        "name": "loanrule_code_num",
        "type": [
          "null",
          "int"
        ]
      }
    ]
})}}


_TEST_RECORDS = {
  "records": [
    {
      "recordId": "789",
      "data": "oAICoAICoAICoAICoAICLDIwMTctMTEtMTQgMTE6NDM6NDktMDUMc2llcnJhCmxvY2FsAgJvAhICLDIwMTctMTItMDUgMDQ6MDA6MDAtMDUCAAKUAgIAAgItAgpld2EwbgIAAgQxMAICLQICLQICAgACCmV3ICAgAgACCA==",
      "approximateArrivalTimestamp": "2012-04-23T18:25:43.511Z"
    },
    {
      "recordId": "123",
      "data": "oAICoAICoAICoAICoAICLDIwMTctMTEtMTQgMTE6NDM6NTAtMDUMc2llcnJhCmxvY2FsAgJvAlgCLDIwMTctMTItMDUgMDQ6MDA6MDAtMDUCAAKSAwIAAgItAgpmd2owYQIAAgQ2MAICLQICcgIEAgACCmZ3ICAgAgACCg==",
      "approximateArrivalTimestamp": "2012-04-23T18:25:43.511Z"
    },
    {
      "recordId": "456",
      "data": "lgsCSDlhNmZiYmU5LWJkMTAtNDA2Ny05ZmVhLWEwODM4ZGU2YzUyNwIGNzE1Ah4yMzQ1Njc4OTA5ODc2NTQCHDMyMTAxMDk2MTE1MjE1AgZQVUwAAAIyMjAxNy0xMC0wNFQxNjo0MToyNS0wNDowMAA=",
      "approximateArrivalTimestamp": "2012-04-23T18:25:43.511Z"
    }
  ],
  "region": "us-east-1",
  "deliveryStreamArn": "arn:aws:kinesis:EXAMPLE",
  "invocationId": "invocationIdExample"
}


class TestAvroEncoder:

    @pytest.fixture
    def test_avro_encoder_instance(self, requests_mock):
        requests_mock.get(
            'https://test_schema_url', text=json.dumps(_TEST_SCHEMA))
        return AvroEncoder('https://test_schema_url')

    @pytest.fixture
    def test_avro_decoder_instance(self, requests_mock):
        # requests_mock.get(
        #     'https://test_schema_url', text=json.dumps(_TEST_SCHEMA))
        requests_mock.get(
            'https://test_schema_url', text=json.dumps(_CIRC_TRANS_SCHEMA))
        return AvroDecoder('https://test_schema_url')

    def test_get_json_schema(self, test_avro_encoder_instance, test_avro_decoder_instance):
        assert test_avro_encoder_instance.schema == _TEST_SCHEMA['data']['schema']
        assert test_avro_decoder_instance.schema == _CIRC_TRANS_SCHEMA['data']['schema']

    def test_request_error(self, requests_mock):
        requests_mock.get('https://test_schema_url', exc=ConnectTimeout)
        with pytest.raises(AvroClientError):
            AvroEncoder('https://test_schema_url')

    def test_bad_json_error(self, requests_mock):
        requests_mock.get(
            'https://test_schema_url', text='bad json')
        with pytest.raises(AvroClientError):
            AvroEncoder('https://test_schema_url')

    def test_missing_key_error(self, requests_mock):
        requests_mock.get(
            'https://test_schema_url', text=json.dumps({'field': 'value'}))
        with pytest.raises(AvroClientError):
            AvroEncoder('https://test_schema_url')

    def test_encode_record(self, test_avro_encoder_instance, test_avro_decoder_instance):
        TEST_RECORD = {'patron_id': 123, 'library_branch': 'aa'}
        encoded_record = test_avro_encoder_instance.encode_record(TEST_RECORD)
        assert type(encoded_record) is bytes
        assert test_avro_decoder_instance.decode_record(encoded_record) == TEST_RECORD

    def test_encode_record_error(self, test_avro_encoder_instance):
        TEST_RECORD = {'patron_id': 123, 'bad_field': 'bad'}
        with pytest.raises(AvroClientError):
            test_avro_encoder_instance.encode_record(TEST_RECORD)

    def test_encode_batch(self, test_avro_encoder_instance, test_avro_decoder_instance):
        TEST_BATCH = [
            {'patron_id': 123, 'library_branch': 'aa'},
            {'patron_id': 456, 'library_branch': None},
            {'patron_id': 789, 'library_branch': 'bb'}]
        encoded_records = test_avro_encoder_instance.encode_batch(TEST_BATCH)
        assert len(encoded_records) == len(TEST_BATCH)
        for i in range(3):
            assert type(encoded_records[i]) is bytes
            assert test_avro_decoder_instance.decode_record(
                encoded_records[i]) == TEST_BATCH[i]

    def test_encode_batch_error(self, test_avro_encoder_instance):
        BAD_BATCH = [
            {'patron_id': 123, 'library_branch': 'aa'},
            {'patron_id': 456, 'bad_field': 'bad'}]
        with pytest.raises(AvroClientError):
            test_avro_encoder_instance.encode_batch(BAD_BATCH)

    def test_decode_record(self, test_avro_decoder_instance):
        TEST_DECODED_RECORD = {'patron_id': 123, 'library_branch': 'aa'}
        TEST_ENCODED_RECORD = b'\xf6\x01\x02\x04aa'
        assert test_avro_decoder_instance.decode_record(
            TEST_ENCODED_RECORD) == TEST_DECODED_RECORD

    def test_decode_record_error(self, test_avro_decoder_instance):
        TEST_ENCODED_RECORD = b'bad-encoding'
        with pytest.raises(AvroClientError):
            test_avro_decoder_instance.decode_record(TEST_ENCODED_RECORD)
    
    def test_decode_records(self, test_avro_decoder_instance):
        test_record = _TEST_RECORDS.get('records')
        result = ""
        if (type(test_record) is list):
            data = json.dumps(test_record[0]["data"])
            result = test_avro_decoder_instance.decode_record(record=data, encoding="base64")
        print(result)
